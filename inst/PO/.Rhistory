f <- function(par) {
loglik( par = par, m = m, Z = Z, status = status, b = b, B = B )  +
+ (a_gammak - 1) * log(par[k]) - b_gammak * par[k]
}
for ( i in 1:length(gammak)){
par_aux <- par
par_aux[k] <- gammak[i]
res[i] <- f(par_aux)
}
return( res - log(pi_k))
}
loglik <- function(par, ## variables
m, status, Z, b, B){ ## data
q <- length(par) - m
gamma <- matrix(par[(q + 1):(q+m)], ncol = 1)
gamma <- abs(gamma)
beta <- matrix(par[1:q], ncol = 1)
theta <- exp(Z %*% beta)
h0 <-  b %*% gamma
H0 <-  B %*% gamma
res <- sum(status * log(h0 * theta) - H0 * theta)
return(res)
}
bpphfit   <- optim(c(rep(1, m), rep(0, q)), fn = loglik, method = "BFGS", control = list(fnscale=-1), m = m,
status = status, Z = Z, b = b, B = B, hessian = TRUE)
bpphfit   <- optim(c(rep(0, q), rep(1, m)), fn = loglik, method = "BFGS", control = list(fnscale=-1), m = m,
status = status, Z = Z, b = b, B = B, hessian = TRUE)
bpphfit
# data prep
Z <- matrix(model.matrix(coxphfit), nrow = dim(larynx)[1])
colnames(Z) <- names(coxphfit$coefficients)
Z <-  scale(Z, scale = F)
n <- nrow(Z)
q <- ncol(Z)
m <- ceiling(sqrt(n)); cat("m = ", m)
tau <- max(larynx$time); cat("tau = ", tau)
status <-  larynx$status
## Conditionals
l_gammak <- function(pi_k, k, ## variables
par, m, status, Z, b, B){  ## data
gammak <- -log(pi_k); res <- NULL
f <- function(par) {
loglik( par = par, m = m, Z = Z, status = status, b = b, B = B )  +
+ (a_gammak - 1) * log(par[k]) - b_gammak * par[k]
}
for ( i in 1:length(gammak)){
par_aux <- par
par_aux[k] <- gammak[i]
res[i] <- f(par_aux)
}
return( res - log(pi_k))
}
l_betaj <- function(pi_j, j, ## variables
par, m, status, Z, b, B){ ## data
q <- j - m
betaj <- log(pi_j) - log(1 - pi_j); res <- NULL
f <- function(par){
loglik( par = par, m = m, Z = Z, status = status, b = b, B = B ) -
( 1 / 2 ) * (par[j] - m_beta[q]) ^ 2   * 1/S_beta[q, q]
}
for ( i in 1:length(betaj)){
par_aux <- par
par_aux[j] <- betaj[i]
res[i] <- f(par_aux)
}
return(res - log(pi_j) - log(1 - pi_j))
}
# prior
a_gammak = .01
b_gammak = .01
a_gammak / b_gammak
## [1] 1
a_gammak / (b_gammak)^2
## [1] 100
m_beta <- rep(0, q)
S_beta <- diag(100, q, q)
m_beta
S_beta
## ARS within Gibbs sampling
t <- 1
it <- 2000
par_samp <- matrix(NA, it, m + q)
colnames(par_samp) <- c(paste0("beta", 1:q), paste0("gamma", 1:m))
par <- c(rep(0, q), rep(1, m))
par
start_time <- Sys.time()
while(t < it + 1){
for(j in 1:q){
j = 1
samp <- HI::arms( .5, myldens = function(y) l_betaj(y, j = j,
par = par, m = m, Z = Z, b = b, B = B, status = status),
indFunc = function(x){(x > 0) * (x <1)}, n.sample = 1 )
par_samp[t, j] <- log(samp) - log(1 - samp)
par[j] <- par_samp[t, j]
}
for(k in (q+1):(q+m)){
samp <- HI::arms(.5, myldens = function(y) l_gammak(y, k = k,
par = par,m = m, Z = Z, b = b, B = B, status = status),
indFunc = function(x){(x > 0) * (x < 1)}, n.sample = 1 )
par_samp[t, k] <- -log(samp)
par[k] <- par_samp[t, k]
}
cat( "\f", "Iteration", t, " out of ", it,". Time spent ",  Sys.time() - start_time)
t <- t + 1
par = par, m = m, Z = Z, b = b, B = B, status = status),
while(t < it + 1){
for(j in 1:q){
j = 1
samp <- HI::arms( .5, myldens = function(y) l_betaj(y, j = j,
par = par, m = m, Z = Z, b = b, B = B, status = status),
indFunc = function(x){(x > 0) * (x <1)}, n.sample = 1 )
par_samp[t, j] <- log(samp) - log(1 - samp)
par[j] <- par_samp[t, j]
}
for(k in (q+1):(q+m)){
samp <- HI::arms(.5, myldens = function(y) l_gammak(y, k = k,
par = par,m = m, Z = Z, b = b, B = B, status = status),
indFunc = function(x){(x > 0) * (x < 1)}, n.sample = 1 )
par_samp[t, k] <- -log(samp)
par[k] <- par_samp[t, k]
}
cat( "\f", "Iteration", t, " out of ", it,". Time spent ",  Sys.time() - start_time)
t <- t + 1
}
t
t = 1
gc()
j = 1
HI::arms( .5, myldens = function(y) l_betaj(y, j = j,
par = par, m = m, Z = Z, b = b, B = B, status = status),
indFunc = function(x){(x > 0) * (x <1)}, n.sample = 1 )
HI::arms( .5, myldens = function(y) l_betaj(y, j = j,
par = par, m = m, Z = Z, b = b, B = B, status = status),
indFunc = function(x){(x > 0) * (x <1)}, n.sample = 1 )
HI::arms( .5, myldens = function(y) l_betaj(y, j = j,
par = par, m = m, Z = Z, b = b, B = B, status = status),
indFunc = function(x){(x > 0) * (x <1)}, n.sample = 1 )
HI::arms( .5, myldens = function(y) l_betaj(y, j = j,
par = par, m = m, Z = Z, b = b, B = B, status = status),
indFunc = function(x){(x > 0) * (x <1)}, n.sample = 1 )
HI::arms( .5, myldens = function(y) l_betaj(y, j = j,
par = par, m = m, Z = Z, b = b, B = B, status = status),
indFunc = function(x){(x > 0) * (x <1)}, n.sample = 1 )
j
pa
par
m
Z
b
B
status
HI::arms( .5, myldens = function(y) l_betaj(y, j = j,
par = par, m = m, Z = Z, b = b, B = B, status = status),
indFunc = function(x){(x > 0) * (x <1)}, n.sample = 1 )
## Conditionals
l_gammak <- function(pi_k, k, ## variables
par, m, status, Z, b, B){  ## data
j <- m - q
gammak <- -log(pi_k); res <- NULL
f <- function(par) {
loglik( par = par, m = m, Z = Z, status = status, b = b, B = B )  +
+ (a_gammak - 1) * log(par[k]) - b_gammak * par[k]
}
for ( i in 1:length(gammak)){
par_aux <- par
par_aux[k] <- gammak[i]
res[i] <- f(par_aux)
}
return( res - log(pi_k))
}
l_betaj <- function(pi_j, j, ## variables
par, m, status, Z, b, B){ ## data
betaj <- log(pi_j) - log(1 - pi_j); res <- NULL
f <- function(par){
loglik( par = par, m = m, Z = Z, status = status, b = b, B = B ) -
( 1 / 2 ) * (par[j] - m_beta[q]) ^ 2   * 1/S_beta[q, q]
}
for ( i in 1:length(betaj)){
par_aux <- par
par_aux[j] <- betaj[i]
res[i] <- f(par_aux)
}
return(res - log(pi_j) - log(1 - pi_j))
}
# prior
a_gammak = .01
b_gammak = .01
a_gammak / b_gammak
## [1] 1
a_gammak / (b_gammak)^2
## [1] 100
m_beta <- rep(0, q)
S_beta <- diag(100, q, q)
## ARS within Gibbs sampling
t <- 1
it <- 2000
par_samp <- matrix(NA, it, m + q)
colnames(par_samp) <- c(paste0("beta", 1:q), paste0("gamma", 1:m))
par <- c(rep(0, q), rep(1, m))
start_time <- Sys.time()
while(t < it + 1){
for(j in 1:q){
samp <- HI::arms( .5, myldens = function(y) l_betaj(y, j = j,
par = par, m = m, Z = Z, b = b, B = B, status = status),
indFunc = function(x){(x > 0) * (x <1)}, n.sample = 1 )
par_samp[t, j] <- log(samp) - log(1 - samp)
par[j] <- par_samp[t, j]
}
for(k in (q+1):(q+m)){
samp <- HI::arms(.5, myldens = function(y) l_gammak(y, k = k,
par = par,m = m, Z = Z, b = b, B = B, status = status),
indFunc = function(x){(x > 0) * (x < 1)}, n.sample = 1 )
par_samp[t, k] <- -log(samp)
par[k] <- par_samp[t, k]
}
cat( "\f", "Iteration", t, " out of ", it,". Time spent ",  Sys.time() - start_time)
t <- t + 1
}
graphics.off();
set.seed(1)
options(scipen = 9999, OutDec = ".", digits = 4)
library("survival")
data("veteran")
veteran <- veteran[veteran$prior == 0,]
cox <- coxph(Surv(time, status) ~ karno + celltype,
data = veteran)
library(timereg)
fit <- prop.odds(Event(time, status) ~ karno + factor(celltype), data = veteran)
fitspbp <- spsurv::spbp(Surv(time, status) ~ karno + celltype, dat = veteran,
approach = "mle", model = 'po', hessian = T)
setwd("~/Documents/spsurv/inst/PO")
m =10
source('fun.R')
fit1 <- optim(c(rep(1, m), rep(0, q)), fn = loglik, method = "BFGS", control = list(fnscale=-1), m = m,
delta = delta, Z = Z, b = b, B = B, hessian = TRUE)
fit1
fit1 <- optim(c(rep(1, m), rep(0, q)), fn = loglik, method = "BFGS", control = list(fnscale=-1), m = m,
delta = delta, Z = Z, b = b, B = B, hessian = TRUE, control=list(maxit=2000))
fit1 <- optim(c(rep(1, m), rep(0, q)), fn = loglik, method = "BFGS", control = list(fnscale=-1, maxit=2000), m = m,
delta = delta, Z = Z, b = b, B = B, hessian = TRUE)
fit1
rm(list = ls()); graphics.off();
library(survival); library(KMsurv)
setwd("~/Documents/spsurv/inst/PH")
set.seed(1)
################################## MAXIMUM LIKELIHOOD ESTIMATION ##################################
# Cox Model
data("larynx")
dat <- larynx;
dat$status <- dat$delta
dat$age <- scale(larynx$age, scale = F)
## Proportional Odds Example according to Bennet (1983)
rm(list = ls(all = T)); library(survival); data(veteran)
## Only 97 patients with no prior therapy are considered
veteran <- veteran[veteran$prior == 0,]
# Patients with high (over 50) and low performance status (PS)
veteran$PS <- cut(veteran$karno,c(0,50, 100), labels = c("Low", "High"))
# Cell type
veteran$celltype <- factor(veteran$celltype, levels = c("large", "adeno", "smallcell", "squamous"))
# Kaplan Meier
kme_PS <- survfit(formula = Surv(time, status) ~ PS, data = veteran);
# pdf('kmeodds.pdf'); dev.off()
plot(kme_PS, bty = 'n', xlab = "time",lwd = 3, cex.lab = 1.7, cex.axis = 1.7)
kme_celltype <- survfit(formula = Surv(time, status) ~ celltype, data = veteran);
plot(kme_celltype, xlab = "time",lwd = 3, cex.lab = 1.7, cex.axis = 1.7, bty = "n")
plot((1-kme_celltype[1]$surv)/kme_celltype[1]$surv, pch = 19, bty = 'n')
points((1-kme_celltype[2]$surv)/kme_celltype[2]$surv, pch = 2)
plot((1-kme_celltype[1]$surv)/kme_celltype[1]$surv, pch = 19, bty = 'n')
points(log((1-kme_celltype[3]$surv)/kme_celltype[3]$surv), pch = 3)
plot((1-kme_celltype[1]$surv)/kme_celltype[1]$surv, pch = 19, bty = 'n')
points((1-kme_celltype[4]$surv)/kme_celltype[4]$surv, pch = 4)
### Making use of spsurv package
library(spsurv)
# devtools::install_github('rvpanaro/spsurv')
options(scipen=9999)
library(timereg)
# Transformação em dados intervalares
veteran$time_start = veteran$time
veteran$time_end = if_else(veteran$status == 1, veteran$time, Inf)
fit <- prop.odds(Event(time, status) ~ karno + factor(celltype), data = veteran)
summary(fit)
plot(predict.timereg(fit, Z = c(60,0,0,0))$time, predict.timereg(fit, Z = c(0,0,0,0))$S0, bty = 'n', lwd = 4, cex.lab = 1.7, cex.axis = 1.7, xlab = 'time', ylab = '',type = 's')
fit
graphics.off();
set.seed(1)
options(scipen = 9999, OutDec = ".", digits = 4)
library("survival")
data("veteran")
veteran <- veteran[veteran$prior == 0,]
cox <- coxph(Surv(time, status) ~ karno + celltype,
data = veteran)
library(timereg)
fit <- prop.odds(Event(time, status) ~ karno + factor(celltype), data = veteran)
fitspbp <- spsurv::spbp(Surv(time, status) ~ karno + celltype, dat = veteran,
approach = "mle", model = 'po', hessian = T)
fitspbp
fit
## Proportional Odds Example according to Bennet (1983)
rm(list = ls(all = T)); library(survival); data(veteran)
## Only 97 patients with no prior therapy are considered
veteran <- veteran[veteran$prior == 0,]
# Patients with high (over 50) and low performance status (PS)
veteran$PS <- cut(veteran$karno,c(0,50, 100), labels = c("Low", "High"))
# Cell type
veteran$celltype <- factor(veteran$celltype, levels = c("large", "adeno", "smallcell", "squamous"))
# Kaplan Meier
kme_PS <- survfit(formula = Surv(time, status) ~ PS, data = veteran);
# pdf('kmeodds.pdf'); dev.off()
plot(kme_PS, bty = 'n', xlab = "time",lwd = 3, cex.lab = 1.7, cex.axis = 1.7)
kme_celltype <- survfit(formula = Surv(time, status) ~ celltype, data = veteran);
plot(kme_celltype, xlab = "time",lwd = 3, cex.lab = 1.7, cex.axis = 1.7, bty = "n")
plot((1-kme_celltype[1]$surv)/kme_celltype[1]$surv, pch = 19, bty = 'n')
points((1-kme_celltype[2]$surv)/kme_celltype[2]$surv, pch = 2)
plot((1-kme_celltype[1]$surv)/kme_celltype[1]$surv, pch = 19, bty = 'n')
points(log((1-kme_celltype[3]$surv)/kme_celltype[3]$surv), pch = 3)
plot((1-kme_celltype[1]$surv)/kme_celltype[1]$surv, pch = 19, bty = 'n')
points((1-kme_celltype[4]$surv)/kme_celltype[4]$surv, pch = 4)
### Making use of spsurv package
library(spsurv)
# devtools::install_github('rvpanaro/spsurv')
options(scipen=9999)
library(timereg)
# Transformação em dados intervalares
veteran$time_start = veteran$time
veteran$time_end = if_else(veteran$status == 1, veteran$time, Inf)
fit <- prop.odds(Event(time, status) ~ karno + factor(celltype), data = veteran)
summary(fit)
factor(celltype)
# dat$celltype <- relevel(dat$celltype, "large")
fitspbp<- spsurv::spbp(Surv(time, status) ~ karno + celltype, dat = veteran,
approach = "mle", model = 'po', hessian = T)
fitspbp
graphics.off();
rm(list = ls())
graphics.off();
set.seed(1)
options(scipen = 9999, OutDec = ".", digits = 4)
library("survival")
data("veteran")
veteran <- veteran[veteran$prior == 0,]
veteran$celltype <- factor(veteran$celltype, levels = c("large", "adeno", "smallcell", "squamous"))
cox <- coxph(Surv(time, status) ~ karno + celltype,
data = veteran)
library(timereg)
fit <- prop.odds(Event(time, status) ~ karno + celltype, data = veteran)
fit
fitspbp <- spsurv::spbp(Surv(time, status) ~ karno + celltype, dat = veteran,
approach = "mle", model = 'po', hessian = T)
fitspbp
setwd("~/Documents/spsurv/inst/PO")
m =10
source('fun.R')
fit1 <- optim(c(rep(1, m), rep(0, q)), fn = loglik, method = "BFGS", control = list(fnscale=-1, maxit=2000), m = m,
delta = delta, Z = Z, b = b, B = B, hessian = TRUE)
fit1
fit1 <- optim(c(rep(1, m), rep(0, q)), fn = loglik, method = "BFGS", control = list(fnscale = -1, maxit = 2000), m = m,
delta = delta, Z = Z, b = b, B = B, hessian = TRUE)
fit1
fit1$par[11:14]
exp(fit1$par[11:14])
out1 <- list(coefficients=c(age = fit1$par[11], stage2= fit1$par[12],
stage3 = fit1$par[13], stage4 = fit1$par[14]),
var = solve(-fit1$hessian)[11:14, 11:14],
loglik = NA,
score = NA,
iter = NA,
linear.predictors = NA,
residuals = NA,
means = NA,
concordance = NA,
method = "BFGS",
n = length(delta),
nevent = sum(delta),
terms = NA,
assign = NA,
wald.test = coxph.wtest(solve(-fit1$hessian)[11:14, 11:14], fit1$par[11:14])$test,
y = NA,
formula = NA,
call = cox$call
)
class(out1) <- 'coxph'
print(out1)
for (i in 1:4){
print((out1$coefficients[i] + c(-1.96, + 1.96)*sqrt(out1$var[i, i])), digits = 4)
}
print((round(exp(out1$coefficients), 4) - round(exp(fit$coefficients), 4))/round(exp(fit$coefficients), 4) *100)
fit
names(fit)
fit$gamma
as.numericfit$gamma
as.numeric(fit$gamma)
fit$gamma[[1]]
fit$gamma[1]
fit$gamma
print((round(exp(out1$coefficients), 4) - round(exp(fit$gamma), 4))/round(exp(fit$gamma), 4) *100)
print((round(exp(out1$coefficients), 4) - round(exp(fit$gamma), 4))/round(exp(fit$gamma), 4) *100)
print((round(exp(out1$coefficients), 4) - round(exp(fit$gamma), 4))/round(exp(fit$gamma), 4) *100)
# prior
a_gammak = .01
b_gammak = .01
a_gammak / b_gammak
## [1] 1
a_gammak / (b_gammak)^2
## [1] 100
m_beta <- rep(0, q)
S_beta <- diag(100, q, q)
## Gibbs sampling
t <- 1; it <- 2000
par_samp <- matrix(NA, it, m + q); colnames(par_samp) <- c(paste0("gamma", 1:m), paste0("beta", 1:q))
par <- c(rep(1, m), rep(0, q)); start_time <- Sys.time()
while(t < it + 1){
for(k in 1:m){
samp <- HI::arms(.5, myldens = function(y) l_gammak(y, k = k,
par = par,m = m, Z = Z, b = b, B = B, delta = delta),
indFunc = function(x){(x > 0) * (x < 1)}, n.sample = 1 )
par_samp[t, k] <- -log(samp)
par[k] <- par_samp[t, k]
}
for(j in (m + 1):(m + q)){
samp <- HI::arms( .5, myldens = function(y) l_betaj(y, j = j,
par = par, m = m, Z = Z, b = b, B = B, delta = delta),
indFunc = function(x){(x > 0) * (x <1)}, n.sample = 1 )
par_samp[t, j] <- log(samp) - log(1 - samp)
par[j] <- par_samp[t, j]
}
cat( "\f", "Iteration", t, " out of ", it,". Time spent ",  Sys.time() - start_time)
t <- t + 1
}
library(coda)
xtable::xtable(cbind(Median = apply(samp1, 2, median), summary(samp1)[[1]],
HPDL = coda::HPDinterval(samp1)[,1], HPDU = coda::HPDinterval(samp1)[,2])[,c(1,2,3,6,7)], digits = 4)
samp1 <- mcmc(par_samp[((it/2)+1):it,11:14]) # 16.46 sec
coda::traceplot(samp1[,1], main = '', bty = 'n')
coda::traceplot(samp1[,2], main = '', bty = 'n')
coda::traceplot(samp1[,3], main = '', bty = 'n')
coda::traceplot(samp1[,4], main = '', bty = 'n')
densplot(samp1[,1], main = '', bty = 'n')
densplot(samp1[,2], main = '', bty = 'n')
densplot(samp1[,3], main = '', bty = 'n')
densplot(samp1[,4], main = '', bty = 'n')
xtable::xtable(cbind(Median = apply(samp1, 2, median), summary(samp1)[[1]],
HPDL = coda::HPDinterval(samp1)[,1], HPDU = coda::HPDinterval(samp1)[,2])[,c(1,2,3,6,7)], digits = 4)
Z
xtable::xtable(cbind(Median = apply(samp1, 2, median), summary(samp1)[[1]],
HPDL = coda::HPDinterval(samp1)[,1], HPDU = coda::HPDinterval(samp1)[,2])[,c(1,2,3,6,7)], digits = 4)
# prior
a_gammak = .01
b_gammak = .01
a_gammak / b_gammak
## [1] 1
a_gammak / (b_gammak)^2
## [1] 100
m_beta <- rep(0, q)
S_beta <- diag(100, q, q)
veteran$status == delta
k
y
m
tau
b
B
## Gibbs sampling
t <- 1; it <- 2000
par_samp <- matrix(NA, it, m + q); colnames(par_samp) <- c(paste0("gamma", 1:m), paste0("beta", 1:q))
par <- c(rep(1, m), rep(0, q)); start_time <- Sys.time()
while(t < it + 1){
for(k in 1:m){
samp <- HI::arms(.5, myldens = function(y) l_gammak(y, k = k,
par = par,m = m, Z = Z, b = b, B = B, delta = delta),
indFunc = function(x){(x > 0) * (x < 1)}, n.sample = 1 )
par_samp[t, k] <- -log(samp)
par[k] <- par_samp[t, k]
}
for(j in (m + 1):(m + q)){
samp <- HI::arms( .5, myldens = function(y) l_betaj(y, j = j,
par = par, m = m, Z = Z, b = b, B = B, delta = delta),
indFunc = function(x){(x > 0) * (x <1)}, n.sample = 1 )
par_samp[t, j] <- log(samp) - log(1 - samp)
par[j] <- par_samp[t, j]
}
cat( "\f", "Iteration", t, " out of ", it,". Time spent ",  Sys.time() - start_time)
t <- t + 1
}
library(coda)
samp1 <- mcmc(par_samp[((it/2)+1):it,11:14]) # 16.46 sec
coda::traceplot(samp1[,1], main = '', bty = 'n')
coda::traceplot(samp1[,2], main = '', bty = 'n')
coda::traceplot(samp1[,3], main = '', bty = 'n')
coda::traceplot(samp1[,4], main = '', bty = 'n')
densplot(samp1[,1], main = '', bty = 'n')
densplot(samp1[,2], main = '', bty = 'n')
densplot(samp1[,3], main = '', bty = 'n')
densplot(samp1[,4], main = '', bty = 'n')
xtable::xtable(cbind(Median = apply(samp1, 2, median), summary(samp1)[[1]],
HPDL = coda::HPDinterval(samp1)[,1], HPDU = coda::HPDinterval(samp1)[,2])[,c(1,2,3,6,7)], digits = 4)
c( 0.0458, 1.0909, 1.1558, -0.0424)
exp(c( 0.0458, 1.0909, 1.1558, -0.0424))
coef <- c(-0.0533, 1.3307, 1.4123, -0.1556)
coef
print(coef-round(exp(apply(samp1, 2, mean)), 4)/round(exp(apply(samp1, 2, mean)), 4)  *100, digits = 4)
coef
round(exp(apply(samp1, 2, mean)), 4)
coef <- exp(c(-0.0533, 1.3307, 1.4123, -0.1556))
print(coef-round(exp(apply(samp1, 2, mean)), 4)/round(exp(apply(samp1, 2, mean)), 4)  *100, digits = 4)
coef <- exp(c(-0.0533, 1.3307, 1.4123, -0.1556))
coef
coef
round(exp(apply(samp1, 2, mean))
)
print((coef-round(exp(apply(samp1, 2, mean)), 4))/round(exp(apply(samp1, 2, mean)), 4)  *100, digits = 4)
coef <- exp(c(-0.0533, 1.3307, 1.4123, -0.1556))
print((coef-round(exp(apply(samp1, 2, mean)), 4))/round(exp(apply(samp1, 2, mean)), 4)  *100, digits = 4)
