Sw <- SSw/(150-3) #matriz de cov DENTRO de grupos, com divisor (n-G)
Sw
St <- SSt/(150-1) #matriz de cov TOTAL, com divisor (n-1)
St   #Note que: St = SSt/(150-1) = cov(y)
#Atenção ao cálculo com divisor alternativo
Sb2<-betweenCov(yg[,-5],yg[,5])
Sb2 #matriz de cov entre grupos, com divisor (n-1)
Sw2<-withinCov(yg[,-5],yg[,5])
Sw2  #matriz de cov dentro de grupos, com divisor (n-1)
library(biotools)
mt<-boxM(yg[,-5],yg[,5])
names(mt)
mt$cov #fornece as matrizes de covariância de cada grupo: S1, S2 e S3
mt$pooled # = Sw: a matriz de covariância comum aos grupos
#Correlação marginal (de Pearson)
#Correlação parcial: correlação de pares de variáveis dado as demais
library(ppcor)
rp<-pcor(x=y)
round(rp$estimate,4) #correlação parcial (aos pares dado as demais)
rp$p.value #níveis descritivos do teste de independência condicional
#Distância Euclidiana entre observações (originais)
diste<-dist(y)
head(diste)
#já que é simétrica e zero na diagonal,é calculada a matriz triangular
#na triangular existem 150*149/2 elementos
summary(diste)
sort(diste)
diste #não está em formato matricial
diste <- as.matrix(diste)
diste
dim(diste)
head(diste)
#Distância Euclidiana Padronizada
#Distância de Pearson entre observações
distp <- dist(yn) #yn: variável padronizada
#já que é simétrica e zero na diagonal,é calculada a matriz triangular
summary(distp)
sort(distp)
distp #não está em formato matricial
distp <- as.matrix(distp)
distp
dim(distp)
head(distp)
#Distância de Mahalanobis entre observações
y <- iris[,-5]
St <- cov(y)
mi <- colMeans(y)
eigen(St) #Decomposição espectral de St
veSt <- eigen(St)$vectors #autovetores de St
vaSt <- eigen(St)$values  #autovalores de St
vaStmeio <- diag(sqrt(vaSt)) #matriz diagonal:raiz quadrada dos autovalores ^1/2
ivaStmeio <- solve(vaStmeio)
iStmeio <- veSt%*%ivaStmeio%*%t(veSt) #matriz St^(-1/2)
ymh <- as.matrix((y-mi))%*%iStmeio #transformação de mahalanobis dos dados
head(cbind(y,ymh)) #dados originais e transformados
distm <- dist(ymh) #distância de mahalanobis
#já que é simétrica e zero na diagonal,é calculada a matriz triangular
summary(distm)
sort(distm)
distm #não está em formato matricial
distm <- as.matrix(distp)
distm
dim(distm)
head(distm)
#Distância de Mahalanobis das observações ao centróide
dm2 <- mahalanobis(y, colMeans(y), cov(y))
dm2
plot(density(dm2, bw = 0.5),
main="Dist Mahalanobis ^2, n=150, p=4") ; rug(dm2)
qqplot(qchisq(ppoints(150), df = 4), dm2,
main = expression("Q-Q plot de Mahalanobis:" * ~dm^2 *
" vs. quantis de" * ~ chi[4]^2))
#Distância de Mahalanobis das observações ao centróide
dm2 <- mahalanobis(y, colMeans(y), cov(y))
dm2
plot(density(dm2, bw = 0.5),
main="Dist Mahalanobis ^2, n=150, p=4") ; rug(dm2)
qqplot(qchisq(ppoints(150), df = 4), dm2,
main = expression("Q-Q plot de Mahalanobis:" * ~dm^2 *
" vs. quantis de" * ~ chi[4]^2))
abline(0, 1, col = 'gray')
ymh.o<-cbind(seq(1:150),dm2)
plot(ymh.o, main="Observações Atípicas - p=4")
abline(h=qchisq(c(0.9), df = 4, lower.tail = TRUE))
#Boxplot univariado
boxplot(y[,1])
boxplot(y[,2])
boxplot(y[,3])
boxplot(y[,4])
bivbox<-function(a, d = 7, mtitle = "Bivariate Boxplot",
method = "robust",xlab="X",ylab="Y")
{
#a is data matrix
#d is constant(usually 7)
p <- length(a[1,  ])
if(method == "robust") {
param <- biweight(a[, 1:2]); m1 <- param[1]; m2 <- param[2]
s1 <- param[3]; s2 <- param[4]; r <- param[5]
}
else {
m1 <- mean(a[, 1]); m2 <- mean(a[, 2]);
s1 <- sqrt(var(a[, 1])); s2 <- sqrt(var(a[, 2])); r <- cor(a[, 1:2])[1, 2]
}
x <- (a[, 1] - m1)/s1; y <- (a[, 2] - m2)/s2
e <- sqrt((x * x + y * y - 2 * r * x * y)/(1 - r * r))
e2 <- e * e; em <- median(e); emax <- max(e[e2 < d * em * em])
r1 <- em * sqrt((1 + r)/2); r2 <- em * sqrt((1 - r)/2); theta <- ((2 * pi)/360) * seq(0, 360, 3)
xp <- m1 + (r1 * cos(theta) + r2 * sin(theta)) * s1; yp <- m2 + (r1 * cos(theta) - r2 * sin(theta)) * s2
r1 <- emax * sqrt((1 + r)/2); r2 <- emax * sqrt((1 - r)/2); theta <- ((2 * pi)/360) * seq(0, 360, 3)
xpp <- m1 + (r1 * cos(theta) + r2 * sin(theta)) * s1; ypp <- m2 + (r1 * cos(theta) - r2 * sin(theta)) * s2
maxxl <- max(xpp); minxl <- min(xpp); maxyl <- max(ypp); minyl <- min(ypp)
b1 <- (r * s2)/s1; a1 <- m2 - b1 * m1; y1 <- a1 + b1 * minxl; y2 <- a1 + b1 * maxxl
b2 <- (r * s1)/s2; a2 <- m1 - b2 * m2; x1 <- a2 + b2 * minyl; x2 <- a2 + b2 * maxyl
maxx <- max(c(a[, 1], xp, xpp, x1, x2)); minx <- min(c(a[, 1], xp, xpp, x1, x2))
maxy <- max(c(a[, 2], yp, ypp, y1, y2)); miny <- min(c(a[, 2], yp, ypp, y1, y2))
plot(a[, 1], a[, 2], xlim = c(minx, maxx), ylim = c(miny, maxy), xlab =xlab, ylab =ylab,
lwd = 2, pch = 1)
lines(xp, yp, lwd = 2); lines(xpp, ypp, lty = 2, lwd = 2)
segments(minxl, y1, maxxl, y2, lty = 3, lwd = 2); segments(x1, minyl, x2, maxyl, lty = 4, lwd = 2)
}
par(mfrow=c(2,3))
bivbox(y[,c(1,2)], method ="O")
bivbox(y[,c(1,3)], method ="O")
bivbox(y[,c(1,4)], method ="O")
bivbox(y[,c(2,3)], method ="O")
bivbox(y[,c(2,4)], method ="O")
bivbox(y[,c(3,4)], method ="O")
boxplot(y)
y
#Distância de Mahalanobis das observações ao centróide
dm2 <- mahalanobis(y, colMeans(y), cov(y))
dm2
plot(density(dm2, bw = 0.5),
main="Dist Mahalanobis ^2, n=150, p=4") ; rug(dm2)
X11()
plot(density(dm2, bw = 0.5),
main="Dist Mahalanobis ^2, n=150, p=4") ; rug(dm2)
qqplot(qchisq(ppoints(150), df = 4), dm2,
main = expression("Q-Q plot de Mahalanobis:" * ~dm^2 *
" vs. quantis de" * ~ chi[4]^2))
iris[, "Petal.Length"]
iris[, c("Petal.Length", "Setal.Length", "Petal.Width", "Setal.Width")]
c("Petal.Length", "Setal.Length", "Petal.Width", "Setal.Width")
iris <- iris[, colnames(iris) %in% c("Petal.Length", "Setal.Length", "Petal.Width", "Setal.Width")]
iris
iris
iris
iris <- iris[, colnames(iris) %in% c("Petal.Length", "Sepal.Length", "Petal.Width", "Sepal.Width", "Species")]
iris
data("iris")
iris <- iris[, colnames(iris) %in% c("Petal.Length", "Sepal.Length", "Petal.Width", "Sepal.Width", "Species")]
iris
iris
data("iris")
iris <- iris[, c(3,1, 4,2,5)]
## Matriz de covariância
iris %>%
select(-Species) %>%
cov  %>%
{. ->> St }
# library(ppcor)
iris %>%
select(-Species) %>%
ppcor::pcor(x = .) %>%
.$estimate %>%
round(., 4) %>%
{. ->> rp}
iris
iris
iris %>%
select(-Species)
iris %>%
select(-Species)
iris %>%
select(-Species)
iris %>%
select(-Species)
iris %>%
select(-Species)
iris %>%
select(-Species)
iris %>%
select(-Species)
iris %>%
select(-Species)
iris %>%
select(-Species)
iris[,-5] %>%
ppcor::pcor(x = .) %>%
.$estimate %>%
round(., 4) %>%
{. ->> rp}
rp
rp[lower.tri(rp)]<-""
pander(rp, caption = "Matriz de correlação parcial")
invSt <- solve(St)
Dinv <- diag(invSt) %>% sqrt %>% diag
solve(Dinv) %*%  -invSt %*% solve(Dinv) %>% round(.,4) == round(rp, 4)
invSt
iris %>%
select(-Species) %>%
scale
iris %>%
select(-Species) %>%
scale
iris %>%
select(-Species) %>%
scale
library("dplyr")
iris %>%
select(-Species) %>%
{dist(., method = "euclidean") ->> euclid} %>%
iris %>%
select(-Species) %>%
scale %>%
{dist(., method = "euclidean") ->> pears}
#Distância de Mahalanobis entre observações
y <- iris[,-5]
St <- cov(y)
mi <- colMeans(y)
eigen(St) #Decomposição espectral de St
veSt <- eigen(St)$vectors #autovetores de St
vaSt <- eigen(St)$values  #autovalores de St
vaStmeio <- diag(sqrt(vaSt)) #matriz diagonal:raiz quadrada dos autovalores ^1/2
ivaStmeio <- solve(vaStmeio)
iStmeio <- veSt%*%ivaStmeio%*%t(veSt) #matriz St^(-1/2)
ymh <- as.matrix((y-mi))%*%iStmeio #transformação de mahalanobis dos dados
head(cbind(y,ymh)) #dados originais e transformados
distm <- dist(ymh) #distância de mahalanobis
#já que é simétrica e zero na diagonal,é calculada a matriz triangular
summary(distm)
sort(distm)
distm #não está em formato matricial
distm <- as.matrix(distp)
distm
dim(distm)
head(distm)
distm <- dist(ymh) #distância de mahalanobis
distm
sort(distm)
sort(distm)[1:3]
#Distância de Mahalanobis das observações ao centróide
dm2 <- mahalanobis(y, colMeans(y), cov(y))
dm2
sort(dm2)[1:3]
sort(dm2, decreasing = F)[1:3]
sort(dm2, decreasing = T)[1:3]
knitr::opts_chunk$set(echo = TRUE)
sqrt_inv_valSt <- sqrt %>%
diag
valSt
## Cálculo de St^(-1/2)
St %>%
eigen %>%
{.$vectors ->> vecSt; .$values ->> valSt}
## Cálculo de St^(-1/2)
St %>%
eigen %>%
{.$vectors ->> vecSt; .$values ->> valSt}
## Cálculo de St^(-1/2)
St %>%
eigen %>%
{.$vectors ->> vecSt; .$values ->> valSt}
library(dplyr); library(pander)
## Total
iris %>%
summarise_if(is.numeric, mean) %>%
t() %>%
round(.,4) %>%
{. ->> center }
## Por grupo
iris %>%
group_by(Species) %>%
summarise_if(is.numeric, mean) %>%
t() %>%
{. ->> centerg }
cbind(rbind("Centróide", center), centerg)[c(1,4,2,5,3),] %>%
pander(., caption = "Vetor de médias: Centróide")
data("iris")
iris <- iris[, c(3,1,4,2,5)]
## Matriz de covariância
iris %>%
select(-Species) %>%
cov  %>%
{. ->> St }
## Matriz de correlação
Rt <- iris %>%
select(-Species) %>%
cor
upper <- round(St, 4)
upper[lower.tri(St)]<-""
pander(upper, caption = "Matriz de covariância")
lower <- round(Rt, 4)
lower[upper.tri(Rt)]<-""
pander(lower, caption = "Matriz de correlação")
paste0("Variância total:  tr(S) =", sum(diag(St)) %>% round(., 4),".\n",
"Variância generalizada: |S| =", det(St) %>% round(., 6),".\n",
"tr(R) = ", sum(diag(Rt)) %>% round(., 4),".\n",
"|R| = ", det(Rt) %>% round(., 6),".\n") %>% cat
iris %>%
select(-Species) %>%
{dist(., method = "euclidean") ->> euclid}
iris %>%
select(-Species) %>%
scale %>%
{dist(., method = "euclidean") ->> pears}
## Cálculo de St^(-1/2)
St %>%
eigen %>%
{.$vectors ->> vecSt; .$values ->> valSt} # autovetores e autovalores de St
sqrt_inv_valSt <- valSt %>%  sqrt %>%
diag %>%
solve %>% {.->> sqrt_inv_valSt}
sqrt_invSt <- vecSt %*% sqrt_inv_valSt %*% t(vecSt) #matriz St^(-1/2)
malah <- (iris[,-5] - center) %>%
as.matrix  %*% sqrt_invSt   ## distância de malahanobis
tab <- cbind(sort(euclid)[1:3],
sort(pears)[1:3],
sort(malah)[1:3]) %>% round(., 4)
colnames(tab) <- c("Euclidean", "Pearson", "Malahanobis")
pander(tab, caption = "As 3 flores mais parecidas")
tab1 <- cbind(sort(euclid, decreasing = T )[1:3],
sort(pears, decreasing = T )[1:3],
sort(malah, decreasing = T )[1:3]) %>%
round(., 4)
colnames(tab1) <- c("Euclidean", "Pearson", "Malahanobis")
pander(tab1, caption = "As 3 flores mais diferentes")
#Distância de Mahalanobis das observações ao centróide
dm2 <- mahalanobis(y, colMeans(y), cov(y))
dm2
plot(density(dm2, bw = 0.5),
main="Dist Mahalanobis ^2, n=150, p=4") ; rug(dm2)
qqplot(qchisq(ppoints(150), df = 4), dm2,
main = expression("Q-Q plot de Mahalanobis:" * ~dm^2 *
" vs. quantis de" * ~ chi[4]^2))
abline(0, 1, col = 'gray')
ymh.o<-cbind(seq(1:150),dm2)
plot(ymh.o, main="Observações Atípicas - p=4")
abline(h=qchisq(c(0.9), df = 4, lower.tail = TRUE))
#Explore as facilidades da library(distances) para cálculos de distâncias
#Boxplot univariado
boxplot(y[,1])
boxplot(y[,2])
boxplot(y[,3])
boxplot(y[,4])
#Boxplot bivariado
#Copiar a função bivbox proposta por Everitt:
bivbox<-function(a, d = 7, mtitle = "Bivariate Boxplot",
method = "robust",xlab="X",ylab="Y")
{
#a is data matrix
#d is constant(usually 7)
p <- length(a[1,  ])
if(method == "robust") {
param <- biweight(a[, 1:2]); m1 <- param[1]; m2 <- param[2]
s1 <- param[3]; s2 <- param[4]; r <- param[5]
}
else {
m1 <- mean(a[, 1]); m2 <- mean(a[, 2]);
s1 <- sqrt(var(a[, 1])); s2 <- sqrt(var(a[, 2])); r <- cor(a[, 1:2])[1, 2]
}
x <- (a[, 1] - m1)/s1; y <- (a[, 2] - m2)/s2
e <- sqrt((x * x + y * y - 2 * r * x * y)/(1 - r * r))
e2 <- e * e; em <- median(e); emax <- max(e[e2 < d * em * em])
r1 <- em * sqrt((1 + r)/2); r2 <- em * sqrt((1 - r)/2); theta <- ((2 * pi)/360) * seq(0, 360, 3)
xp <- m1 + (r1 * cos(theta) + r2 * sin(theta)) * s1; yp <- m2 + (r1 * cos(theta) - r2 * sin(theta)) * s2
r1 <- emax * sqrt((1 + r)/2); r2 <- emax * sqrt((1 - r)/2); theta <- ((2 * pi)/360) * seq(0, 360, 3)
xpp <- m1 + (r1 * cos(theta) + r2 * sin(theta)) * s1; ypp <- m2 + (r1 * cos(theta) - r2 * sin(theta)) * s2
maxxl <- max(xpp); minxl <- min(xpp); maxyl <- max(ypp); minyl <- min(ypp)
b1 <- (r * s2)/s1; a1 <- m2 - b1 * m1; y1 <- a1 + b1 * minxl; y2 <- a1 + b1 * maxxl
b2 <- (r * s1)/s2; a2 <- m1 - b2 * m2; x1 <- a2 + b2 * minyl; x2 <- a2 + b2 * maxyl
maxx <- max(c(a[, 1], xp, xpp, x1, x2)); minx <- min(c(a[, 1], xp, xpp, x1, x2))
maxy <- max(c(a[, 2], yp, ypp, y1, y2)); miny <- min(c(a[, 2], yp, ypp, y1, y2))
plot(a[, 1], a[, 2], xlim = c(minx, maxx), ylim = c(miny, maxy), xlab =xlab, ylab =ylab,
lwd = 2, pch = 1)
lines(xp, yp, lwd = 2); lines(xpp, ypp, lty = 2, lwd = 2)
segments(minxl, y1, maxxl, y2, lty = 3, lwd = 2); segments(x1, minyl, x2, maxyl, lty = 4, lwd = 2)
}
par(mfrow=c(2,3))
bivbox(y[,c(1,2)], method ="O")
bivbox(y[,c(1,3)], method ="O")
bivbox(y[,c(1,4)], method ="O")
bivbox(y[,c(2,3)], method ="O")
bivbox(y[,c(2,4)], method ="O")
bivbox(y[,c(3,4)], method ="O")
iris %>%
select(-Species) %>%
{dist(., method = "euclidean") ->> euclid}
iris %>%
select(-Species) %>%
scale %>%
{dist(., method = "euclidean") ->> pears}
## Cálculo de St^(-1/2)
St %>%
eigen %>%
{.$vectors ->> vecSt; .$values ->> valSt} # autovetores e autovalores de St
sqrt_inv_valSt <- valSt %>%  sqrt %>%
diag %>%
solve %>% {.->> sqrt_inv_valSt}
sqrt_inv_valSt
sqrt_inv_valSt <- valSt %>%  sqrt %>%
diag %>%
solve %>% {.->> sqrt_inv_valSt}
sqrt_inv_valSt
valSt
as.matrix(iris[,-5] - center)
sqrt_invSt
#Distância de Mahalanobis entre observações
y <- iris[,-5]
St <- cov(y)
mi <- colMeans(y)
scale(iris[,-5], scale = F)
dm2 <- mahalanobis(y, colMeans(y), cov(y))
dm2
X11()
plot(density(dm2, bw = 0.5),
main="Dist Mahalanobis ^2, n=150, p=4") ; rug(dm2)
qqplot(qchisq(ppoints(150), df = 4), dm2,
main = expression("Q-Q plot de Mahalanobis:" * ~dm^2 *
" vs. quantis de" * ~ chi[4]^2))
abline(0, 1, col = 'gray')
#Distância de Mahalanobis das observações ao centróide
dm2 <- mahalanobis(y, colMeans(y), cov(y))
dm2
X11()
plot(density(dm2, bw = 0.5),
main="Dist Mahalanobis ^2, n=150, p=4") ; rug(dm2)
ymh.o<-cbind(seq(1:150),dm2)
plot(ymh.o, main="Observações Atípicas - p=4")
abline(h=qchisq(c(0.9), df = 4, lower.tail = TRUE))
qnorm(2,5)
qnorm(2.5)
pnorm(2.5)
pnorm(2.5, lower.tail = F)
pnorm(1.95, lower.tail = F)
qnorm(2.5)
pnorm(2.5)
pnorm(2.5, lower.tail = F)
2*pnorm(2.5, lower.tail = F)
2*pnorm(1.95, lower.tail = F)
plot(scale(iris[,-5])^2)
require(gridExtra)
library(gridExtra)
plot1 <- plot(scale(iris[1,-5])^2)
plot2 <- plot(scale(iris[1,-5])^2)
scale(iris[1,-5])^2
scale(iris[1,-5])^2
scale(iris[1,-5])^2
scale(iris[1,-5])^2
iris[1,-5]
iris[1,-5]
iris[1,-5]
iris[1,-5]
iris[1,-5]
iris[1,-5]
iris[, 1]
scale(iris[, 1])
plot1 <- plot(scale(iris[, 1])^2)
plot2 <- plot(scale(iris[, 2])^2)
plot3 <- plot(scale(iris[, 3])^2)
plot3 <- plot(scale(iris[, 4])^2)
par(mfrow  = c(2,2))
plot(scale(iris[, 1])^2)
plot(scale(iris[, 2])^2)
plot(scale(iris[, 3])^2)
plot(scale(iris[, 4])^2)
library(gridExtra)
par(mfrow  = c(2,2))
for(i in 1:4){
plot(scale(iris[, i])^2)
abline(h=qchisq(c(0.9), df = 1, lower.tail = TRUE))
}
qchisq(c(0.9), df = 4, lower.tail = TRUE)
qchisq(c(0.9), df = 1, lower.tail = TRUE)
install.packages("spsurv")
?spbp
?spsurv
??spsurv
vignette("spsurv")
vignette("spsurv")
library("KMsurv")
data("larynx")
library(spsurv)
fit <- spsurv::spbp(Surv(time, delta)~ age + factor(stage),
approach = "mle",  data = larynx)
summary(fit)
fit <- spsurv::spbp(Surv(time, delta)~ age,
approach = "mle",  data = larynx)
summary(fit)
summary(fit)
fit <- spsurv::spbp(Surv(time, delta)~ factor(stage),
approach = "mle",  data = larynx)
fit <- spsurv::spbp(Surv(time, delta)~ age + factor(stage),
approach = "mle",  data = larynx)
summary(fit)
fit <- spsurv::spbp(Surv(time, delta)~ age + factor(stage) + age,
approach = "mle",  data = larynx)
summary(fit)
fit <- spsurv::spbp(Surv(time, delta)~ + factor(stage) + I(age),
approach = "mle",  data = larynx)
summary(fit)
fit <- spsurv::spbp(Surv(time, delta)~ + factor(stage) + I(age. 2),
approach = "mle",  data = larynx)
fit <- spsurv::spbp(Surv(time, delta)~ + factor(stage) + I(age, 2),
approach = "mle",  data = larynx)
summary(fit)
larynx
fit <- spsurv::spbp(Surv(time, delta)~ age + diagyr + factor(stage),
approach = "mle",  data = larynx)
summary(fit)
vignette("spsurv")
exp(1)
