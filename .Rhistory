mf <- eval(temp, parent.frame())
if (nrow(mf) == 0) stop("Only missing observations")
Terms <- terms(mf)
Y <- model.extract(mf, "response") # in general, time-to-event response
if (!inherits(Y, "Surv")) stop("Response must be a survival object")
type <- attr(Y, "type")
if (type!='right' && type!='counting')
stop(paste("Proportional hazards model doesn't support \"", type,
"\" survival data", sep=''))
if (length(attr(Terms, 'variables')) > 2) { # a ~1 formula has length 2
ytemp <- terms.inner(formula)[1:2]
xtemp <- terms.inner(formula)[-c(1,2)]
if (any(!is.na(match(xtemp, ytemp))))
warning("a variable appears on both the left and right sides of
the formula")
}
#-------------------------------------------------------------------
## --------------- Model Fitting ---------------
## Data
data.n <- nrow(Y)
labels <- attributes(temp$formula)$term.labels
null <- 0
if (length(labels) > 1){
X <-  model.matrix(Terms, mf)[, -1]
}
else if(length(labels) == 1){
X <- as.matrix(model.matrix(Terms, mf)[, -1], ncol = data.n)
colnames(X) <- labels
}
else{
X <- as.matrix(rep(0, data.n), ncol = data.n)
colnames(X) <- "non-parametric"
null <- 1
}
features <- X
attr(X, "assign") <- attr(model.matrix(Terms, mf), "assign")[-1]
attr(X, "contrasts") <- attr(model.matrix(Terms, mf), "contrasts")
xlevels <- .getXlevels(Terms, mf)
contrasts <- attr(X, "contrasts")
assign <- attrassign(X, Terms)
X <-  scale(X, scale = T)
q <- ncol(X)
time <- as.vector(Y[,1])
status <- as.vector(Y[,2])
# base calculations
base <- bp_basis(time, degree = degree, tau = tau)
# data
standata <- list(time = time, tau = tau, n = data.n, degree = degree, q = q,
status = status, X = X, B = base$B, b = base$b,
approach = approach, M = model, null = null)
## Stanfit
standata <- c(standata, priors)
# mle
if(approach == 0){
stanfit <- rstan::optimizing(stanmodels$spbp, data = standata,
init = init, hessian = hessian,
verbose = verbose, ...)
## stanfit coefficients (beta, nu)
coef <- stanfit$par
## rescaled coefficients
coef[1:q] <- stanfit$par[1:q] / attr(X, 'scaled:scale')
## regression estimates
beta <- coef[1:q]
## rescaled hessian matrix
hess <- stanfit$hessian
hess[1:q, 1:q] <- stanfit$hessian[1:q, 1:q]/(attr(X, 'scaled:scale'))^2
names(beta) <- colnames(X)
names(coef) <- c(names(beta), paste0("log(gamma", 1:(length(stanfit$par)-q), ")"))
## singular matrices handler
if(det(-hess) == 0)
stop("Optimizing hesssian matrix is singular!")
## rescaled fisher info
info <- NA
tol <- .Machine$double.eps ## solve default tolerance
class(info) <- "try-error"
while(class(info) == "try-error"){
info <- try(solve(-hess, tol = tol), silent = T)
tol <- tol/2
}
if(hessian == FALSE || null == 1){
stanfit$hessian <- matrix(rep(NA, q^2), ncol = 1:q,
nrow = 1:q)
}
nulldata <- standata
nulldata$null <- 1
nullfit <- rstan::optimizing(stanmodels$spbp, data = nulldata, init = init,
hessian = hessian, ...)
output <- list(coefficients = coef,
var = info,
loglik = c(nullfit$value, stanfit$value),
linear.predictors = c(features %*% beta),
means = colMeans(features),
method = algorithm,
n = data.n,
nevent = sum(status),
q = q,
terms = Terms,
assign = assign,
wald.test = coxph.wtest(info, stanfit$par)$test,
y = Y,
formula = formula,
xlevels = xlevels,
contrasts = contrasts,
call = Call,
return_code = stanfit$return_code
)
}
else{   # bayes
output <- list()
stanfit <- rstan::sampling(stanmodels$spbp, data = standata,
verbose = verbose, ...)
output$stanfit <- stanfit
}
output$model <- model_flag
output$approach <- approach_flag
class(output) <- "spbp"
return(output)
}
fit <- spbp(Surv(time, status) ~ x1 + x2, data = dat,
model = 'ph', approach = 'mle')
spbp <- function(formula, degree = ceiling(sqrt(length(time))),
tau = max(time), data,
approach = c("mle", "bayes"),
model = c("ph", "po", "aft"),
priors = list(shape_gamma = .01, rate_gamma = .01,
mean_beta = 0, sd_beta = 10),
hessian = TRUE, verbose = FALSE,
init = 0, algorithm = "LBFGS", ...) {
print(is.integer(degree))
## --------------- Degree error handling ---------------
if(!is.integer(degree))
stop('Polynomial degree must be integer.')
#-------------------------------------------------------------------
model_flag <- model; approach_flag <- approach ### creates flags to save char
model <- ifelse(match.arg(model) == "po", 0,
ifelse(match.arg(model) == "ph", 1, 2))
approach <- ifelse(match.arg(approach) == "mle", 0, 1)
## --------------- Formula => model.frame args error handling ---------------
# evaluate model.frame() containing the required formula
Call <- match.call()
aux <- match(c("formula", "data", "degree", "tau"),
names(Call), nomatch = 0)
if (aux[1] == 0) stop("A formula argument is required")
if (aux[2] == 0) stop("A dataset argument is required")
## --------------- Approach error handling ---------------
defaultPriors <- list(shape_gamma = .01, rate_gamma = .01, mean_beta = 0,
sd_beta = 10)
## case 1: bayes aproach w/ wrong prior spec.
if(approach == 1 & !is.null(priors)){
if(sum(c('shape_gamma','rate_gamma','mean_beta', 'sd_beta') %in% names(priors)) < 4) stop('Prior arguments do not match.')
}
## case 2: ## case 1: bayes aproach wout/ prior spec
else if(approach == 1 &  sum(priors %in% defaultPriors) == 4){
message('Due to bayes approach, default priors are attributed,
see approach in ??bpph().')
}
## case 3: mle approach w/ prior spec.
else{
if(!is.null(priors))message('Due to mle approach priors are ignored.')
}
#-------------------------------------------------------------------
## --------------- Extra args error handling ---------------
##  ... arguments directly passed to `rstan::stan`, handles typos
## like "chans=4".
stanArgs <- list(...)
if (length(stanArgs)) {
ifelse(approach == 0,
stanformals <- c(names(formals(rstan::stan)),
"seed", "check_data", "sample_file",
~~"algorithm", "verbose", "hessian", "as_vector",
"draws", "constrained", "save_iterations",
"refresh", "init_alpha", "tol_obj",
"tol_rel_obj", "tol_grad", "tol_rel_grad",
"tol_param", "history_size"),
stanformals <- names(formals(rstan::stan))) #legal arg names
aux <- pmatch(names(stanArgs), stanformals, nomatch = 0)
if (any(aux == 0))
stop(gettextf("Argument %s not matched", names(stanArgs)[aux==0]))
}
#-------------------------------------------------------------------
temp <- Call[c(1, aux)]  # keep important args
temp[[1L]] <- quote(stats::model.frame)  # model frame call
temp$formula <- terms(formula, data = data);
mf <- eval(temp, parent.frame())
if (nrow(mf) == 0) stop("Only missing observations")
Terms <- terms(mf)
Y <- model.extract(mf, "response") # in general, time-to-event response
if (!inherits(Y, "Surv")) stop("Response must be a survival object")
type <- attr(Y, "type")
if (type!='right' && type!='counting')
stop(paste("Proportional hazards model doesn't support \"", type,
"\" survival data", sep=''))
if (length(attr(Terms, 'variables')) > 2) { # a ~1 formula has length 2
ytemp <- terms.inner(formula)[1:2]
xtemp <- terms.inner(formula)[-c(1,2)]
if (any(!is.na(match(xtemp, ytemp))))
warning("a variable appears on both the left and right sides of
the formula")
}
#-------------------------------------------------------------------
## --------------- Model Fitting ---------------
## Data
data.n <- nrow(Y)
labels <- attributes(temp$formula)$term.labels
null <- 0
if (length(labels) > 1){
X <-  model.matrix(Terms, mf)[, -1]
}
else if(length(labels) == 1){
X <- as.matrix(model.matrix(Terms, mf)[, -1], ncol = data.n)
colnames(X) <- labels
}
else{
X <- as.matrix(rep(0, data.n), ncol = data.n)
colnames(X) <- "non-parametric"
null <- 1
}
features <- X
attr(X, "assign") <- attr(model.matrix(Terms, mf), "assign")[-1]
attr(X, "contrasts") <- attr(model.matrix(Terms, mf), "contrasts")
xlevels <- .getXlevels(Terms, mf)
contrasts <- attr(X, "contrasts")
assign <- attrassign(X, Terms)
X <-  scale(X, scale = T)
q <- ncol(X)
time <- as.vector(Y[,1])
status <- as.vector(Y[,2])
# base calculations
base <- bp_basis(time, degree = degree, tau = tau)
# data
standata <- list(time = time, tau = tau, n = data.n, degree = degree, q = q,
status = status, X = X, B = base$B, b = base$b,
approach = approach, M = model, null = null)
## Stanfit
standata <- c(standata, priors)
# mle
if(approach == 0){
stanfit <- rstan::optimizing(stanmodels$spbp, data = standata,
init = init, hessian = hessian,
verbose = verbose, ...)
## stanfit coefficients (beta, nu)
coef <- stanfit$par
## rescaled coefficients
coef[1:q] <- stanfit$par[1:q] / attr(X, 'scaled:scale')
## regression estimates
beta <- coef[1:q]
## rescaled hessian matrix
hess <- stanfit$hessian
hess[1:q, 1:q] <- stanfit$hessian[1:q, 1:q]/(attr(X, 'scaled:scale'))^2
names(beta) <- colnames(X)
names(coef) <- c(names(beta), paste0("log(gamma", 1:(length(stanfit$par)-q), ")"))
## singular matrices handler
if(det(-hess) == 0)
stop("Optimizing hesssian matrix is singular!")
## rescaled fisher info
info <- NA
tol <- .Machine$double.eps ## solve default tolerance
class(info) <- "try-error"
while(class(info) == "try-error"){
info <- try(solve(-hess, tol = tol), silent = T)
tol <- tol/2
}
if(hessian == FALSE || null == 1){
stanfit$hessian <- matrix(rep(NA, q^2), ncol = 1:q,
nrow = 1:q)
}
nulldata <- standata
nulldata$null <- 1
nullfit <- rstan::optimizing(stanmodels$spbp, data = nulldata, init = init,
hessian = hessian, ...)
output <- list(coefficients = coef,
var = info,
loglik = c(nullfit$value, stanfit$value),
linear.predictors = c(features %*% beta),
means = colMeans(features),
method = algorithm,
n = data.n,
nevent = sum(status),
q = q,
terms = Terms,
assign = assign,
wald.test = coxph.wtest(info, stanfit$par)$test,
y = Y,
formula = formula,
xlevels = xlevels,
contrasts = contrasts,
call = Call,
return_code = stanfit$return_code
)
}
else{   # bayes
output <- list()
stanfit <- rstan::sampling(stanmodels$spbp, data = standata,
verbose = verbose, ...)
output$stanfit <- stanfit
}
output$model <- model_flag
output$approach <- approach_flag
class(output) <- "spbp"
return(output)
}
fit <- spbp(Surv(time, status) ~ x1 + x2, data = dat,
model = 'ph', approach = 'mle')
10 %mod%
1
10 %/%
1
10%%1==0
10.1%%1==0
source('inst/load.R')
rm(list = ls())
## Weibull simulated data: Inverse transform method
n <- 100
beta1 <- 2; beta2 = -1
lambdaT <- .002 # baseline hazard
lambdaC <- .004  # hazard of censoring
x1 <- rnorm(n, 0)
x2 <- rnorm(n, 0)
gamma <- 2
t <- rweibull(n, shape = gamma, scale = (lambdaT*exp(beta1*x1 + beta2*x2)^(-1/gamma))) #proportional hazards
c <- rweibull(n, shape = gamma, scale = lambdaC)   #censoring time
time <- pmin(t,c)  #observed time is min between censored and event
status <- as.numeric(time == t)   # set to 1 if event is observed
mean(status)
dat <- data.frame(time, status, x1, x2)
library(spsurv) # semiparametric survival
fit <- spbp(Surv(time, status) ~ x1 + x2, data = dat,
model = 'ph', approach = 'mle')
fit
spbp <- function(formula, degree = ceiling(sqrt(length(time))),
tau = max(time), data,
approach = c("mle", "bayes"),
model = c("ph", "po", "aft"),
priors = list(shape_gamma = .01, rate_gamma = .01,
mean_beta = 0, sd_beta = 10),
hessian = TRUE, verbose = FALSE,
init = 0, algorithm = "LBFGS", ...) {
## --------------- Degree error handling ---------------
if(!(degree %% 1 == 0))
stop('Polynomial degree must be integer.')
#-------------------------------------------------------------------
model_flag <- model; approach_flag <- approach ### creates flags to save char
model <- ifelse(match.arg(model) == "po", 0,
ifelse(match.arg(model) == "ph", 1, 2))
approach <- ifelse(match.arg(approach) == "mle", 0, 1)
## --------------- Formula => model.frame args error handling ---------------
# evaluate model.frame() containing the required formula
Call <- match.call()
aux <- match(c("formula", "data", "degree", "tau"),
names(Call), nomatch = 0)
if (aux[1] == 0) stop("A formula argument is required")
if (aux[2] == 0) stop("A dataset argument is required")
## --------------- Approach error handling ---------------
defaultPriors <- list(shape_gamma = .01, rate_gamma = .01, mean_beta = 0,
sd_beta = 10)
## case 1: bayes aproach w/ wrong prior spec.
if(approach == 1 & !is.null(priors)){
if(sum(c('shape_gamma','rate_gamma','mean_beta', 'sd_beta') %in% names(priors)) < 4) stop('Prior arguments do not match.')
}
## case 2: ## case 1: bayes aproach wout/ prior spec
else if(approach == 1 &  sum(priors %in% defaultPriors) == 4){
message('Due to bayes approach, default priors are attributed,
see approach in ??bpph().')
}
## case 3: mle approach w/ prior spec.
else{
if(!is.null(priors))message('Due to mle approach priors are ignored.')
}
#-------------------------------------------------------------------
## --------------- Extra args error handling ---------------
##  ... arguments directly passed to `rstan::stan`, handles typos
## like "chans=4".
stanArgs <- list(...)
if (length(stanArgs)) {
ifelse(approach == 0,
stanformals <- c(names(formals(rstan::stan)),
"seed", "check_data", "sample_file",
~~"algorithm", "verbose", "hessian", "as_vector",
"draws", "constrained", "save_iterations",
"refresh", "init_alpha", "tol_obj",
"tol_rel_obj", "tol_grad", "tol_rel_grad",
"tol_param", "history_size"),
stanformals <- names(formals(rstan::stan))) #legal arg names
aux <- pmatch(names(stanArgs), stanformals, nomatch = 0)
if (any(aux == 0))
stop(gettextf("Argument %s not matched", names(stanArgs)[aux==0]))
}
#-------------------------------------------------------------------
temp <- Call[c(1, aux)]  # keep important args
temp[[1L]] <- quote(stats::model.frame)  # model frame call
temp$formula <- terms(formula, data = data);
mf <- eval(temp, parent.frame())
if (nrow(mf) == 0) stop("Only missing observations")
Terms <- terms(mf)
Y <- model.extract(mf, "response") # in general, time-to-event response
if (!inherits(Y, "Surv")) stop("Response must be a survival object")
type <- attr(Y, "type")
if (type!='right' && type!='counting')
stop(paste("Proportional hazards model doesn't support \"", type,
"\" survival data", sep=''))
if (length(attr(Terms, 'variables')) > 2) { # a ~1 formula has length 2
ytemp <- terms.inner(formula)[1:2]
xtemp <- terms.inner(formula)[-c(1,2)]
if (any(!is.na(match(xtemp, ytemp))))
warning("a variable appears on both the left and right sides of
the formula")
}
#-------------------------------------------------------------------
## --------------- Model Fitting ---------------
## Data
data.n <- nrow(Y)
labels <- attributes(temp$formula)$term.labels
null <- 0
if (length(labels) > 1){
X <-  model.matrix(Terms, mf)[, -1]
}
else if(length(labels) == 1){
X <- as.matrix(model.matrix(Terms, mf)[, -1], ncol = data.n)
colnames(X) <- labels
}
else{
X <- as.matrix(rep(0, data.n), ncol = data.n)
colnames(X) <- "non-parametric"
null <- 1
}
features <- X
attr(X, "assign") <- attr(model.matrix(Terms, mf), "assign")[-1]
attr(X, "contrasts") <- attr(model.matrix(Terms, mf), "contrasts")
xlevels <- .getXlevels(Terms, mf)
contrasts <- attr(X, "contrasts")
assign <- attrassign(X, Terms)
X <-  scale(X, scale = T)
q <- ncol(X)
time <- as.vector(Y[,1])
status <- as.vector(Y[,2])
# base calculations
base <- bp_basis(time, degree = degree, tau = tau)
# data
standata <- list(time = time, tau = tau, n = data.n, degree = degree, q = q,
status = status, X = X, B = base$B, b = base$b,
approach = approach, M = model, null = null)
## Stanfit
standata <- c(standata, priors)
print(standata)
# mle
if(approach == 0){
stanfit <- rstan::optimizing(stanmodels$spbp, data = standata,
init = init, hessian = hessian,
verbose = verbose, ...)
## stanfit coefficients (beta, nu)
coef <- stanfit$par
## rescaled coefficients
coef[1:q] <- stanfit$par[1:q] / attr(X, 'scaled:scale')
## regression estimates
beta <- coef[1:q]
## rescaled hessian matrix
hess <- stanfit$hessian
hess[1:q, 1:q] <- stanfit$hessian[1:q, 1:q]/(attr(X, 'scaled:scale'))^2
names(beta) <- colnames(X)
names(coef) <- c(names(beta), paste0("log(gamma", 1:(length(stanfit$par)-q), ")"))
## singular matrices handler
if(det(-hess) == 0)
stop("Optimizing hesssian matrix is singular!")
## rescaled fisher info
info <- NA
tol <- .Machine$double.eps ## solve default tolerance
class(info) <- "try-error"
while(class(info) == "try-error"){
info <- try(solve(-hess, tol = tol), silent = T)
tol <- tol/2
}
if(hessian == FALSE || null == 1){
stanfit$hessian <- matrix(rep(NA, q^2), ncol = 1:q,
nrow = 1:q)
}
nulldata <- standata
nulldata$null <- 1
nullfit <- rstan::optimizing(stanmodels$spbp, data = nulldata, init = init,
hessian = hessian, ...)
output <- list(coefficients = coef,
var = info,
loglik = c(nullfit$value, stanfit$value),
linear.predictors = c(features %*% beta),
means = colMeans(features),
method = algorithm,
n = data.n,
nevent = sum(status),
q = q,
terms = Terms,
assign = assign,
wald.test = coxph.wtest(info, stanfit$par)$test,
y = Y,
formula = formula,
xlevels = xlevels,
contrasts = contrasts,
call = Call,
return_code = stanfit$return_code
)
}
else{   # bayes
output <- list()
stanfit <- rstan::sampling(stanmodels$spbp, data = standata,
verbose = verbose, ...)
output$stanfit <- stanfit
}
output$model <- model_flag
output$approach <- approach_flag
class(output) <- "spbp"
return(output)
}
fit <- spbp(Surv(time, status) ~ x1 + x2, data = dat,
model = 'ph', approach = 'mle')
